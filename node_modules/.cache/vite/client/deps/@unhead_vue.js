import {
  getCurrentInstance,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  ref,
  unref,
  version,
  watch,
  watchEffect
} from "./chunk-BVQHDTV7.js";
import {
  asArray,
  composableNames,
  createHead,
  createHeadCore,
  createServerHead,
  defineHeadPlugin,
  getActiveHead,
  unpackMeta,
  whitelistSafeInput
} from "./chunk-SKWH7X7G.js";

// node_modules/@unhead/vue/dist/shared/vue.505b826e.mjs
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}
function resolveUnrefHeadInput(ref2, lastKey = "") {
  if (ref2 instanceof Promise)
    return ref2;
  const root = resolveUnref(ref2);
  if (!ref2 || !root)
    return root;
  if (Array.isArray(root))
    return root.map((r) => resolveUnrefHeadInput(r, lastKey));
  if (typeof root === "object") {
    return Object.fromEntries(
      Object.entries(root).map(([k, v]) => {
        if (k === "titleTemplate" || k.startsWith("on"))
          return [k, unref(v)];
        return [k, resolveUnrefHeadInput(v, k)];
      })
    );
  }
  return root;
}
var Vue3 = version.startsWith("3");
var IsBrowser = typeof window !== "undefined";
var headSymbol = "usehead";
function injectHead() {
  return getCurrentInstance() && inject(headSymbol) || getActiveHead();
}
function vueInstall(head) {
  const plugin = {
    install(app) {
      if (Vue3) {
        app.config.globalProperties.$unhead = head;
        app.config.globalProperties.$head = head;
        app.provide(headSymbol, head);
      }
    }
  };
  return plugin.install;
}
function createServerHead2(options = {}) {
  const head = createServerHead({
    ...options,
    plugins: [
      VueReactiveUseHeadPlugin(),
      ...(options == null ? void 0 : options.plugins) || []
    ]
  });
  head.install = vueInstall(head);
  return head;
}
function createHead2(options = {}) {
  const head = createHead({
    ...options,
    // arbitrary delay the dom update for batch updates
    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),
    plugins: [
      VueReactiveUseHeadPlugin(),
      ...(options == null ? void 0 : options.plugins) || []
    ]
  });
  head.install = vueInstall(head);
  return head;
}
function VueReactiveUseHeadPlugin() {
  return defineHeadPlugin({
    hooks: {
      "entries:resolve": function(ctx) {
        for (const entry of ctx.entries)
          entry.resolvedInput = resolveUnrefHeadInput(entry.input);
      }
    }
  });
}
function clientUseHead(input, options = {}) {
  const head = injectHead();
  const deactivated = ref(false);
  const resolvedInput = ref({});
  watchEffect(() => {
    resolvedInput.value = deactivated.value ? {} : resolveUnrefHeadInput(input);
  });
  const entry = head.push(resolvedInput.value, options);
  watch(resolvedInput, (e) => {
    entry.patch(e);
  });
  const vm = getCurrentInstance();
  if (vm) {
    onBeforeUnmount(() => {
      entry.dispose();
    });
    onDeactivated(() => {
      deactivated.value = true;
    });
    onActivated(() => {
      deactivated.value = false;
    });
  }
  return entry;
}
function serverUseHead(input, options = {}) {
  const head = injectHead();
  return head.push(input, options);
}
function useHead(input, options = {}) {
  var _a;
  const head = injectHead();
  if (head) {
    const isBrowser = IsBrowser || !!((_a = head.resolvedOptions) == null ? void 0 : _a.document);
    if (options.mode === "server" && isBrowser || options.mode === "client" && !isBrowser)
      return;
    return isBrowser ? clientUseHead(input, options) : serverUseHead(input, options);
  }
}

// node_modules/@unhead/vue/dist/index.mjs
var VueHeadMixin = {
  created() {
    const instance = getCurrentInstance();
    if (!instance)
      return;
    const options = instance.type;
    if (!options || !("head" in options))
      return;
    const source = typeof options.head === "function" ? () => options.head.call(instance.proxy) : options.head;
    useHead(source);
  }
};
var Vue2ProvideUnheadPlugin = function(_Vue, head) {
  _Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      const origProvide = options.provide;
      options.provide = function() {
        let origProvideResult;
        if (typeof origProvide === "function")
          origProvideResult = origProvide.call(this);
        else
          origProvideResult = origProvide || {};
        return {
          ...origProvideResult,
          [headSymbol]: head
        };
      };
    }
  });
};
function useHeadSafe(input, options = {}) {
  return useHead(input, { ...options, transform: whitelistSafeInput });
}
function useSeoMeta(input, options) {
  const headInput = ref({});
  watchEffect(() => {
    const resolvedMeta = resolveUnrefHeadInput(input);
    const { title, titleTemplate, ...meta } = resolvedMeta;
    headInput.value = {
      title,
      titleTemplate,
      meta: unpackMeta(meta)
    };
  });
  return useHead(headInput, options);
}
function useServerHead(input, options = {}) {
  return serverUseHead(input, { ...options, mode: "server" });
}
function useServerHeadSafe(input, options = {}) {
  return useHeadSafe(input, { ...options, mode: "server" });
}
function useServerSeoMeta(input, options) {
  return useSeoMeta(input, { ...options || {}, mode: "server" });
}
function useTagTitle(title) {
  return useHead({ title });
}
function useTitleTemplate(titleTemplate) {
  return useHead({ titleTemplate });
}
function useTagMeta(meta) {
  return useHead({ meta: asArray(meta) });
}
function useTagMetaFlat(meta) {
  const input = ref({});
  watchEffect(() => {
    input.value = unpackMeta(resolveUnrefHeadInput(meta));
  });
  return useHead({ meta: input });
}
function useTagLink(link) {
  return useHead({ link: asArray(link) });
}
function useTagScript(script) {
  return useHead({ script: asArray(script) });
}
function useTagStyle(style) {
  return useHead({ style: asArray(style) });
}
function useTagNoscript(noscript) {
  return useHead({ noscript: asArray(noscript) });
}
function useTagBase(base) {
  return useHead({ base });
}
function useHtmlAttrs(attrs) {
  return useHead({ htmlAttrs: attrs });
}
function useBodyAttrs(attrs) {
  return useHead({ bodyAttrs: attrs });
}
function useServerTagTitle(title) {
  return useServerHead({ title });
}
function useServerTitleTemplate(titleTemplate) {
  return useServerHead({ titleTemplate });
}
function useServerTagMeta(meta) {
  return useServerHead({ meta: asArray(meta) });
}
function useServerTagMetaFlat(meta) {
  const input = ref({});
  watchEffect(() => {
    input.value = unpackMeta(resolveUnrefHeadInput(meta));
  });
  return useServerHead({ meta: input });
}
function useServerTagLink(link) {
  return useServerHead({ link: asArray(link) });
}
function useServerTagScript(script) {
  return useServerHead({ script: asArray(script) });
}
function useServerTagStyle(style) {
  return useServerHead({ style: asArray(style) });
}
function useServerTagNoscript(noscript) {
  return useServerHead({ noscript: asArray(noscript) });
}
function useServerTagBase(base) {
  return useServerHead({ base });
}
function useServerHtmlAttrs(attrs) {
  return useServerHead({ htmlAttrs: attrs });
}
function useServerBodyAttrs(attrs) {
  return useHead({ bodyAttrs: attrs });
}
var coreComposableNames = [
  "injectHead"
];
var unheadVueComposablesImports = {
  "@unhead/vue": [...coreComposableNames, ...composableNames]
};
export {
  Vue2ProvideUnheadPlugin,
  VueHeadMixin,
  VueReactiveUseHeadPlugin,
  createHead2 as createHead,
  createHeadCore,
  createServerHead2 as createServerHead,
  headSymbol,
  injectHead,
  resolveUnrefHeadInput,
  unheadVueComposablesImports,
  useBodyAttrs,
  useHead,
  useHeadSafe,
  useHtmlAttrs,
  useSeoMeta,
  useServerBodyAttrs,
  useServerHead,
  useServerHeadSafe,
  useServerHtmlAttrs,
  useServerSeoMeta,
  useServerTagBase,
  useServerTagLink,
  useServerTagMeta,
  useServerTagMetaFlat,
  useServerTagNoscript,
  useServerTagScript,
  useServerTagStyle,
  useServerTagTitle,
  useServerTitleTemplate,
  useTagBase,
  useTagLink,
  useTagMeta,
  useTagMetaFlat,
  useTagNoscript,
  useTagScript,
  useTagStyle,
  useTagTitle,
  useTitleTemplate
};
//# sourceMappingURL=@unhead_vue.js.map
